public final class InterpolationHelper {public static final char BEGIN_TERM = '{';public static final char END_TERM = '}';public static final char EL_DESIGNATOR = '$';public static final char ESCAPE_CHARACTER = '\\';private static final Pattern ESCAPE_MESSAGE_PARAMETER_PATTERN = Pattern.compile("([\\" + ESCAPE_CHARACTER + BEGIN_TERM + END_TERM + EL_DESIGNATOR + "])");private InterpolationHelper() {}if (messageParameter == null) {return null;}return ESCAPE_MESSAGE_PARAMETER_PATTERN.matcher(messageParameter).replaceAll(Matcher.quoteReplacement(String.valueOf(ESCAPE_CHARACTER)) + "$1");}/*** Escape EL expressions to avoid template injection attacks.** This has serious security implications and you will**/boolean escapeExpressions() default true;private boolean escapeExpressions = true;escapeExpressions = constraintAnnotation.escapeExpressions();final ViolationCollector collector = new ViolationCollector(context);final ViolationCollector collector = new ViolationCollector(context, escapeExpressions);private static final Pattern ESCAPE_PATTERN = Pattern.compile("\\$\\{");private final ConstraintValidatorContext constraintValidatorContext;private final boolean escapeExpressions;private ConstraintValidatorContext context;public ViolationCollector(ConstraintValidatorContext constraintValidatorContext) {this(constraintValidatorContext, true);}public ViolationCollector(ConstraintValidatorContext context) {this.context = context;public ViolationCollector(ConstraintValidatorContext constraintValidatorContext, boolean escapeExpressions) {this.constraintValidatorContext = constraintValidatorContext;this.escapeExpressions = escapeExpressions;** Prefer the method with explicit message parameters if you want to interpolate the message.addViolation(message, Collections.emptyMap());}/****/public void addViolation(String message, Map messageParameters) {String messageTemplate = escapeEl(message);context.buildConstraintViolationWithTemplate(messageTemplate)getContextWithMessageParameters(messageParameters).buildConstraintViolationWithTemplate(sanitizeTemplate(message))** Prefer the method with explicit message parameters if you want to interpolate the message.addViolation(propertyName, message, Collections.emptyMap());}/****/public void addViolation(String propertyName, String message, Map messageParameters) {String messageTemplate = escapeEl(message);context.buildConstraintViolationWithTemplate(messageTemplate)getContextWithMessageParameters(messageParameters).buildConstraintViolationWithTemplate(sanitizeTemplate(message))* Prefer the method with explicit message parameters if you want to interpolate the message.addViolation(propertyName, index, message, Collections.emptyMap());}/****/public void addViolation(String propertyName, Integer index, String message, Map messageParameters) {String messageTemplate = escapeEl(message);context.buildConstraintViolationWithTemplate(messageTemplate)getContextWithMessageParameters(messageParameters).buildConstraintViolationWithTemplate(sanitizeTemplate(message))addViolation(propertyName, key, message, Collections.emptyMap());}/****/public void addViolation(String propertyName, String key, String message, Map messageParameters) {String messageTemplate = escapeEl(message);final String messageTemplate = sanitizeTemplate(message);final HibernateConstraintValidatorContext context = getContextWithMessageParameters(messageParameters);if (s == null || s.isEmpty()) {return s;}final Matcher m = ESCAPE_PATTERN.matcher(s);final StringBuffer sb = new StringBuffer(s.length() + 16);while (m.find()) {m.appendReplacement(sb, "\\\\\\${");private HibernateConstraintValidatorContext getContextWithMessageParameters(Map messageParameters) {final HibernateConstraintValidatorContext context =constraintValidatorContext.unwrap(HibernateConstraintValidatorContext.class);for (Map.Entry messageParameter : messageParameters.entrySet()) {final Object value = messageParameter.getValue();final String escapedValue = value == null ? null : escapeMessageParameter(value.toString());context.addMessageParameter(messageParameter.getKey(), escapedValue);m.appendTail(sb);return context;}return sb.toString();return escapeExpressions ? escapeMessageParameter(message) : message;return context;return constraintValidatorContext;col.addViolation("$\\A{1+1}");col.addViolation("{value}", Collections.singletonMap("value", "TEST"));public static class EscapingDisabledExample {public void validateFail(ViolationCollector col) {col.addViolation("${'value'}");col.addViolation("$\\A{1+1}");col.addViolation("{value}", Collections.singletonMap("value", "TEST"));col.addViolation("${'property'}", "${'value'}");col.addViolation("${'property'}", 1, "${'value'}");col.addViolation("${'property'}", "${'key'}", "${'value'}");}}public static class MessageParametersExample {public void validateFail(ViolationCollector col) {col.addViolation("{1+1}");col.addViolation("{value}", Collections.singletonMap("value", "VALUE"));col.addViolation("No parameter", Collections.singletonMap("value", "VALUE"));col.addViolation("{value} {unsetParameter}", Collections.singletonMap("value", "VALUE"));col.addViolation("{value", Collections.singletonMap("value", "VALUE"));col.addViolation("value}", Collections.singletonMap("value", "VALUE"));col.addViolation("{  value  }", Collections.singletonMap("value", "VALUE"));col.addViolation("Mixed ${'value'} {value}", Collections.singletonMap("value", "VALUE"));col.addViolation("Nested {value}", Collections.singletonMap("value", "${'nested'}"));col.addViolation("{property}", "{value}", ImmutableMap.of("property", "PROPERTY", "value", "VALUE"));col.addViolation("{property}", 1, "{value}", ImmutableMap.of("property", "PROPERTY", "value", "VALUE"));col.addViolation("{property}", "{key}", "{value}", ImmutableMap.of("property", "PROPERTY", "key", "KEY", "value", "VALUE"));}}public void violationMessagesAreEscaped() {public void violationMessagesAreEscapedByDefault() {" $\\A{1+1}"," {value}",public void violationMessagesAreInterpolatedIfEscapingDisabled() {assertThat(ConstraintViolations.format(validator.validate(new EscapingDisabledExample()))).containsExactly(" A2"," TEST"," value","${'property'} value","${'property'}[${'key'}] value","${'property'}[1] value");}public void messageParametersExample() {assertThat(ConstraintViolations.format(validator.validate(new MessageParametersExample()))).containsExactly(" Mixed value VALUE"," Nested ${'nested'}"," No parameter"," VALUE"," VALUE {unsetParameter}"," value}"," {  value  }"," {1+1}"," {value","{property} VALUE","{property}[1] VALUE","{property}[{key}] VALUE");}